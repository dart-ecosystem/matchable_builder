import 'dart:async';
import 'dart:io';

import 'package:analyzer/dart/element/element.dart';
import 'package:build/src/builder/build_step.dart';
import 'package:build/src/builder/builder.dart';
import 'package:matchable_builder/src/AbstractMatchableBuilder.dart';
import 'package:matchable_builder/src/support/RequiredImport.dart';
import 'package:matchable_builder/src/support/RequiredPart.dart';

abstract class MatchablePartBuilder extends AbstractMatchableBuilder {
  MatchablePartBuilder(BuilderOptions options) : super(options);

  List<RequiredImport> get requiredImports;

  List<RequiredPart> get requiredParts;

  @override
  Future<void> runGenerate(
    LibraryElement library,
    List<Element> elements,
    BuildStep buildStep,
  ) async {
    await _ensureRequiredImports(library, elements, buildStep);
    await _ensureRequiredParts(library, elements, buildStep);
    await generate(library, elements, buildStep);
  }

  Future<void> _ensureRequiredImports(
      LibraryElement library, List<Element> elements, BuildStep buildStep) async {
    final imports = [...requiredImports];

    if (imports.isEmpty) {
      return;
    }

    if (imports.any((r) => r.path == 'dart:core' && r.prefix != null)) {
      imports.add(RequiredImport(path: 'dart:core', prefix: null));
    }

    final lines = (await buildStep.readAsString(buildStep.inputId)).split('\n');

    for (final import in imports) {
      final shouldGenerate = !library.imports.any(
        (p) => p.uri == import.path && p.prefix?.name == import.prefix,
      );
      if (shouldGenerate) {
        final libraryLineNumber = lines.indexWhere((line) => line.startsWith('library'));

        var generatedLine =
            import.render(library, elements, buildStep) + ' // Generated by ${this.runtimeType}';

        lines.insert(
          libraryLineNumber + 1,
          generatedLine,
        );
      }
    }

    final file = File(buildStep.inputId.path);
    final outputContent = lines.join('\n');
    await file.writeAsString(outputContent, flush: true);
  }

  Future<void> _ensureRequiredParts(
    LibraryElement library,
    List<Element> elements,
    BuildStep buildStep,
  ) async {
    final parts = [...requiredParts];

    if (parts.isEmpty) {
      return;
    }

    final lines = (await buildStep.readAsString(buildStep.inputId)).split('\n');

    for (final part in parts) {
      final shouldGenerate = !library.parts.any((p) => part.match(p, library, elements, buildStep));
      if (shouldGenerate) {
        var lastImportLineNumber = -1;
        for (var i = 0; i < lines.length; i++) {
          if (lines[i].startsWith('import')) {
            lastImportLineNumber = i;
          }
        }

        var generatedLine =
            part.render(library, elements, buildStep) + ' // Generated by ${this.runtimeType}';

        lines.insert(
          lastImportLineNumber + 1,
          generatedLine,
        );
      }
    }

    final file = File(buildStep.inputId.path);
    final outputContent = lines.join('\n');
    await file.writeAsString(outputContent, flush: true);
  }

  Future<void> generate(
    LibraryElement library,
    List<Element> elements,
    BuildStep buildStep,
  );
}
